#!/usr/bin/env tsx

/**
 * validate-clob-only-scale.ts
 *
 * Batch validation of V29 PnL against CLOB-only wallets at scale.
 * Processes samples generated by sample-clob-only-validation-set.ts
 * and produces rolling statistics with incremental checkpoints.
 */

import { createClient } from '@clickhouse/client';
import * as fs from 'fs';
import * as path from 'path';

const clickhouse = createClient({
  url: process.env.CLICKHOUSE_HOST,
  username: process.env.CLICKHOUSE_USER,
  password: process.env.CLICKHOUSE_PASSWORD,
  database: process.env.CLICKHOUSE_DATABASE || 'default',
});

interface WalletCandidate {
  wallet: string;
  clob_events: number;
  redemption_events: number;
  split_events: number;
  merge_events: number;
  condition_count: number;
  cash_flow: number;
}

interface SampleFile {
  metadata: {
    sample_size: number;
    generated_at: string;
    total_candidates: number;
    filter_criteria: string;
  };
  wallets: WalletCandidate[];
}

interface V29Result {
  wallet: string;
  total_pnl: number;
  clob_events: number;
  redemption_events: number;
  split_events: number;
  merge_events: number;
  cash_flow: number;
  error_vs_cash: number;
  error_pct: number;
}

interface RollingStats {
  count: number;
  clob_only_classified: number;
  positive_pnl: number;
  negative_pnl: number;
  mean_pnl: number;
  median_pnl: number;
  cash_sign_match: number;
  error_under_100: number;
  error_under_1000: number;
  correlation_r2: number;
}

function calculateStats(results: V29Result[]): RollingStats {
  const n = results.length;

  // CLOB-only classification (should be 100% given our filter)
  const clobOnly = results.filter(r => r.split_events === 0 && r.merge_events === 0).length;

  // PnL distribution
  const positivePnL = results.filter(r => r.total_pnl > 0).length;
  const negativePnL = results.filter(r => r.total_pnl < 0).length;

  const meanPnL = results.reduce((sum, r) => sum + r.total_pnl, 0) / n;

  const sortedPnL = [...results].sort((a, b) => a.total_pnl - b.total_pnl);
  const medianPnL = n % 2 === 0
    ? (sortedPnL[n / 2 - 1].total_pnl + sortedPnL[n / 2].total_pnl) / 2
    : sortedPnL[Math.floor(n / 2)].total_pnl;

  // Cash flow sign match
  const cashSignMatch = results.filter(r => {
    const v29Sign = r.total_pnl > 0 ? 1 : r.total_pnl < 0 ? -1 : 0;
    const cashSign = r.cash_flow > 0 ? 1 : r.cash_flow < 0 ? -1 : 0;
    return v29Sign === cashSign;
  }).length;

  // Error thresholds
  const errorUnder100 = results.filter(r => Math.abs(r.error_vs_cash) < 100).length;
  const errorUnder1000 = results.filter(r => Math.abs(r.error_vs_cash) < 1000).length;

  // Correlation R²
  const meanCash = results.reduce((sum, r) => sum + r.cash_flow, 0) / n;
  const ssTotal = results.reduce((sum, r) => sum + Math.pow(r.total_pnl - meanPnL, 2), 0);
  const ssRes = results.reduce((sum, r) => sum + Math.pow(r.total_pnl - r.cash_flow, 2), 0);
  const r2 = ssTotal > 0 ? 1 - (ssRes / ssTotal) : 0;

  return {
    count: n,
    clob_only_classified: clobOnly,
    positive_pnl: positivePnL,
    negative_pnl: negativePnL,
    mean_pnl: meanPnL,
    median_pnl: medianPnL,
    cash_sign_match: cashSignMatch,
    error_under_100: errorUnder100,
    error_under_1000: errorUnder1000,
    correlation_r2: r2,
  };
}

function printDashboard(stats: RollingStats, topWallets: V29Result[]) {
  const pct = (n: number) => ((n / stats.count) * 100).toFixed(1);

  console.log('\n═══════════════════════════════════════════════════════════════');
  console.log(`  SCALE VALIDATION DASHBOARD (N=${stats.count})`);
  console.log('═══════════════════════════════════════════════════════════════');
  console.log(`  Classifier agreement (CLOB_ONLY): ${stats.clob_only_classified}/${stats.count} (${pct(stats.clob_only_classified)}%)`);
  console.log(`\n  V29 vs Cash Flow Correlation: R²=${stats.correlation_r2.toFixed(4)}`);
  console.log(`\n  PnL Distribution:`);
  console.log(`    Positive PnL:  ${stats.positive_pnl} wallets (${pct(stats.positive_pnl)}%)`);
  console.log(`    Negative PnL:  ${stats.negative_pnl} wallets (${pct(stats.negative_pnl)}%)`);
  console.log(`    Mean PnL:      $${stats.mean_pnl.toFixed(2)}`);
  console.log(`    Median PnL:    $${stats.median_pnl.toFixed(2)}`);
  console.log(`\n  Consistency Metrics:`);
  console.log(`    Cash flow sign matches V29:  ${pct(stats.cash_sign_match)}%`);
  console.log(`    |Error| < $100:              ${pct(stats.error_under_100)}%`);
  console.log(`    |Error| < $1000:             ${pct(stats.error_under_1000)}%`);

  console.log(`\n  Top 10 Largest V29 PnL:`);
  topWallets.slice(0, 10).forEach((w, i) => {
    console.log(`    ${i + 1}. ${w.wallet} $${w.total_pnl.toFixed(2)}`);
  });

  console.log('═══════════════════════════════════════════════════════════════\n');
}

async function validateWallet(wallet: string, _expectedCashFlow: number): Promise<V29Result> {
  const query = `
    SELECT
      wallet_address as wallet,
      sum(
        CASE
          WHEN payout_norm IS NOT NULL AND payout_norm >= 0
          THEN usdc_delta + (token_delta * payout_norm)
          ELSE usdc_delta
        END
      ) as total_pnl,
      sumIf(usdc_delta, source_type = 'CLOB') as cash_flow,
      countIf(source_type = 'CLOB') as clob_events,
      countIf(source_type = 'PayoutRedemption') as redemption_events,
      countIf(source_type = 'PositionSplit') as split_events,
      countIf(source_type = 'PositionsMerge') as merge_events
    FROM pm_unified_ledger_v8_tbl
    WHERE wallet_address = {wallet:String}
    GROUP BY wallet_address
  `;

  const result = await clickhouse.query({
    query,
    query_params: { wallet },
    format: 'JSONEachRow',
  });

  const rows: any[] = await result.json();

  if (rows.length === 0) {
    return {
      wallet,
      total_pnl: 0,
      clob_events: 0,
      redemption_events: 0,
      split_events: 0,
      merge_events: 0,
      cash_flow: 0,
      error_vs_cash: 0,
      error_pct: 0,
    };
  }

  const row = rows[0];
  const totalPnL = parseFloat(row.total_pnl || 0);
  const cashFlow = parseFloat(row.cash_flow || 0);
  const error = totalPnL - cashFlow;
  const errorPct = cashFlow !== 0 ? Math.abs(error / cashFlow) * 100 : 0;

  return {
    wallet,
    total_pnl: totalPnL,
    clob_events: parseInt(row.clob_events || 0),
    redemption_events: parseInt(row.redemption_events || 0),
    split_events: parseInt(row.split_events || 0),
    merge_events: parseInt(row.merge_events || 0),
    cash_flow: cashFlow,
    error_vs_cash: error,
    error_pct: errorPct,
  };
}

async function validateSample(samplePath: string) {
  console.log('══════════════════════════════════════════════════════════════');
  console.log('  CLOB-ONLY SCALE VALIDATION');
  console.log('══════════════════════════════════════════════════════════════\n');

  // Load sample
  const sampleData: SampleFile = JSON.parse(fs.readFileSync(samplePath, 'utf-8'));
  console.log(`Loaded sample: ${samplePath}`);
  console.log(`  Sample size: ${sampleData.metadata.sample_size}`);
  console.log(`  Generated: ${sampleData.metadata.generated_at}`);
  console.log(`  Filter: ${sampleData.metadata.filter_criteria}\n`);

  const tmpDir = path.join(process.cwd(), 'tmp');
  const progressPath = path.join(tmpDir, 'clob_scale_progress.jsonl');
  const partialPath = path.join(tmpDir, 'clob_scale_partial.json');

  // Clear previous progress files
  if (fs.existsSync(progressPath)) fs.unlinkSync(progressPath);
  if (fs.existsSync(partialPath)) fs.unlinkSync(partialPath);

  const results: V29Result[] = [];
  const batchSize = 25;

  for (let i = 0; i < sampleData.wallets.length; i++) {
    const candidate = sampleData.wallets[i];

    process.stdout.write(`\rProcessing wallet ${i + 1}/${sampleData.wallets.length}...`);

    const result = await validateWallet(candidate.wallet, candidate.cash_flow);
    results.push(result);

    // Write progress log
    fs.appendFileSync(progressPath, JSON.stringify(result) + '\n');

    // Checkpoint every 25 wallets
    if ((i + 1) % batchSize === 0 || i === sampleData.wallets.length - 1) {
      const stats = calculateStats(results);
      const topWallets = [...results].sort((a, b) => b.total_pnl - a.total_pnl);

      // Write partial results
      fs.writeFileSync(partialPath, JSON.stringify({
        processed: i + 1,
        total: sampleData.wallets.length,
        stats,
        results,
      }, null, 2));

      // Print dashboard
      console.log(''); // New line after progress
      printDashboard(stats, topWallets);
    }
  }

  console.log('\n✓ Validation complete\n');

  // Write final results
  const finalPath = path.join(tmpDir, `clob_scale_final_${sampleData.metadata.sample_size}.json`);
  const stats = calculateStats(results);
  const topWallets = [...results].sort((a, b) => b.total_pnl - a.total_pnl);

  fs.writeFileSync(finalPath, JSON.stringify({
    metadata: sampleData.metadata,
    validation_completed_at: new Date().toISOString(),
    stats,
    results,
  }, null, 2));

  console.log(`Final results written to: ${finalPath}`);

  // Generate report
  await generateReport(sampleData.metadata, stats, results);

  await clickhouse.close();
}

async function generateReport(
  metadata: SampleFile['metadata'],
  stats: RollingStats,
  results: V29Result[]
) {
  const tmpDir = path.join(process.cwd(), 'tmp');
  const reportPath = path.join(tmpDir, 'agent_scale_report.md');

  const pct = (n: number) => ((n / stats.count) * 100).toFixed(1);

  const sortedByPnL = [...results].sort((a, b) => b.total_pnl - a.total_pnl);
  const sortedByError = [...results].sort((a, b) => Math.abs(b.error_vs_cash) - Math.abs(a.error_vs_cash));

  const report = `# CLOB-Only Scale Validation Report

**Generated:** ${new Date().toISOString()}
**Sample Size:** ${metadata.sample_size} wallets
**Source Sample:** Generated at ${metadata.generated_at}

---

## 1. Sample Composition

**Filter Criteria:**
\`\`\`
${metadata.filter_criteria}
\`\`\`

**Event Count Distribution:**
- CLOB events: ${Math.min(...results.map(r => r.clob_events))} - ${Math.max(...results.map(r => r.clob_events))}
- Average CLOB events: ${(results.reduce((sum, r) => sum + r.clob_events, 0) / stats.count).toFixed(1)}
- Total candidates in pool: ${metadata.total_candidates}

---

## 2. V29 PnL Distribution Statistics

**Overall:**
- Mean PnL: $${stats.mean_pnl.toFixed(2)}
- Median PnL: $${stats.median_pnl.toFixed(2)}
- Min PnL: $${sortedByPnL[sortedByPnL.length - 1].total_pnl.toFixed(2)}
- Max PnL: $${sortedByPnL[0].total_pnl.toFixed(2)}

**Distribution:**
- Positive PnL: ${stats.positive_pnl} wallets (${pct(stats.positive_pnl)}%)
- Negative PnL: ${stats.negative_pnl} wallets (${pct(stats.negative_pnl)}%)
- Zero PnL: ${stats.count - stats.positive_pnl - stats.negative_pnl} wallets

---

## 3. Classifier Accuracy

**CLOB-Only Classification:**
- Correctly classified: ${stats.clob_only_classified}/${stats.count} (${pct(stats.clob_only_classified)}%)
- Split events detected: ${results.filter(r => r.split_events > 0).length}
- Merge events detected: ${results.filter(r => r.merge_events > 0).length}

**Expected:** 100% accuracy (prefiltered for CLOB-only wallets)

---

## 4. Cash Flow vs V29 Correlation

**Correlation Coefficient:**
- R² = ${stats.correlation_r2.toFixed(4)}

**Sign Agreement:**
- Cash flow sign matches V29: ${stats.cash_sign_match}/${stats.count} (${pct(stats.cash_sign_match)}%)

**Error Distribution:**
- |Error| < $100: ${stats.error_under_100}/${stats.count} (${pct(stats.error_under_100)}%)
- |Error| < $1000: ${stats.error_under_1000}/${stats.count} (${pct(stats.error_under_1000)}%)
- |Error| ≥ $1000: ${stats.count - stats.error_under_1000}/${stats.count} (${pct(stats.count - stats.error_under_1000)}%)

---

## 5. Outlier Identification

### Top 10 Largest V29 PnL
${sortedByPnL.slice(0, 10).map((r, i) =>
  `${i + 1}. ${r.wallet} - $${r.total_pnl.toFixed(2)} (vs cash: $${r.cash_flow.toFixed(2)}, error: ${r.error_pct.toFixed(1)}%)`
).join('\n')}

### Top 10 Largest Errors (V29 - Cash Flow)
${sortedByError.slice(0, 10).map((r, i) =>
  `${i + 1}. ${r.wallet} - Error: $${r.error_vs_cash.toFixed(2)} (${r.error_pct.toFixed(1)}%) | V29: $${r.total_pnl.toFixed(2)} | Cash: $${r.cash_flow.toFixed(2)}`
).join('\n')}

---

## 6. Recommendations for Parity Test Thresholds

Based on the validation results:

### Proposed Thresholds
1. **Error Tolerance:** ±$1000 absolute error (covers ${pct(stats.error_under_1000)}% of wallets)
2. **Percentage Tolerance:** ±5% relative error for wallets with |PnL| > $1000
3. **Sign Agreement:** Required for all wallets (currently ${pct(stats.cash_sign_match)}%)

### Quality Gates
- **Minimum R² for acceptance:** 0.95
- **Minimum sign agreement:** 95%
- **Maximum outlier rate (>$1000 error):** 5%

### Current Performance vs Thresholds
- R² threshold (0.95): ${stats.correlation_r2 >= 0.95 ? '✓ PASS' : '✗ FAIL'} (${stats.correlation_r2.toFixed(4)})
- Sign agreement (95%): ${(stats.cash_sign_match / stats.count) >= 0.95 ? '✓ PASS' : '✗ FAIL'} (${pct(stats.cash_sign_match)}%)
- Outlier rate (<5%): ${((stats.count - stats.error_under_1000) / stats.count) <= 0.05 ? '✓ PASS' : '✗ FAIL'} (${pct(stats.count - stats.error_under_1000)}%)

---

## Conclusion

${stats.correlation_r2 >= 0.95 && (stats.cash_sign_match / stats.count) >= 0.95 && ((stats.count - stats.error_under_1000) / stats.count) <= 0.05
  ? '✓ **VALIDATION PASSED** - V29 PnL engine shows high accuracy for CLOB-only wallets at scale.'
  : '⚠️ **VALIDATION NEEDS REVIEW** - Some quality thresholds not met. Review outliers and error distribution.'
}

**Next Steps:**
1. ${results.filter(r => r.split_events > 0 || r.merge_events > 0).length > 0 ? 'Investigate wallets with split/merge events (should be 0 for this sample)' : 'Expand validation to wallets with split/merge events'}
2. ${stats.correlation_r2 < 0.95 ? 'Investigate low correlation - review V29 formula against cash flow expectations' : 'Run validation on larger sample (500-1000 wallets)'}
3. Review top error outliers for potential data quality issues
4. Compare results with Polymarket UI benchmarks for subset of wallets
`;

  fs.writeFileSync(reportPath, report);
  console.log(`\n✓ Report written to: ${reportPath}\n`);
}

// Main execution
const samplePath = process.argv[2];

if (!samplePath) {
  console.error('Usage: tsx validate-clob-only-scale.ts <sample-file-path>');
  console.error('Example: tsx validate-clob-only-scale.ts tmp/clob_only_validation_sample_100.json');
  process.exit(1);
}

validateSample(samplePath).catch(console.error);
