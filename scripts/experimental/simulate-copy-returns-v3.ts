/**
 * Simulate Copy Trading Returns v3 - USE PRE-COMPUTED METRICS
 *
 * The CLOB table is too slow for per-trade analysis.
 * Instead, use the pre-computed pm_copy_trading_metrics_v1 which already has:
 * - realized_pnl (actual returns)
 * - win_rate
 * - avg_win_pct / avg_loss_pct
 * - total_trades / positions_count
 *
 * This gives us a THEORETICAL simulation based on historical metrics.
 *
 * @author Claude (Edge Detection Approach)
 */

import dotenv from 'dotenv'
dotenv.config({ path: '.env.local' })
import { clickhouse } from '@/lib/clickhouse/client'

// Load top wallets from edge-leaderboard.json (generated by edge-hunt-v3.ts)
import * as fs from 'fs'
const leaderboardData = JSON.parse(fs.readFileSync('/Users/scotty/Projects/Cascadian-app/scripts/experimental/results/edge-leaderboard.json', 'utf-8'))
const TOP_WALLETS = leaderboardData.slice(0, 15).map((w: any) => ({
  wallet: w.wallet,
  note: `Rank #${w.rank} | WR: ${(w.win_rate * 100).toFixed(0)}% | W/L: ${w.win_loss_asymmetry.toFixed(1)}x`
}))

async function runSimulation() {
  console.log('╔═══════════════════════════════════════════════════════════════════════════════════════╗')
  console.log('║    COPY TRADING SIMULATION v3 - PRE-COMPUTED METRICS APPROACH                        ║')
  console.log('╠═══════════════════════════════════════════════════════════════════════════════════════╣')
  console.log('║ Uses pm_copy_trading_metrics_v1 for instant results                                  ║')
  console.log('║ Simulates: What if we bet $1 per position with same win rate/avg win/loss?           ║')
  console.log('╚═══════════════════════════════════════════════════════════════════════════════════════╝')
  console.log()

  const walletsStr = TOP_WALLETS.map(w => `'${w.wallet.toLowerCase()}'`).join(',')

  const query = `
    SELECT
      wallet_address as wallet,
      realized_pnl,
      total_pnl,
      volume_usd,
      total_trades,
      positions_count,
      resolved_positions,
      win_count,
      loss_count,
      win_rate,
      avg_win_pct,
      avg_loss_pct,
      breakeven_wr,
      edge_ratio,
      pnl_confidence,
      external_sell_ratio,
      abs(avg_win_pct) / NULLIF(abs(avg_loss_pct), 0) as win_loss_asymmetry
    FROM pm_copy_trading_metrics_v1
    WHERE lower(wallet_address) IN (${walletsStr})
  `

  console.log('📊 Fetching pre-computed metrics...')
  const result = await clickhouse.query({ query, format: 'JSONEachRow' })
  const metrics = await result.json() as any[]

  console.log(`✅ Got metrics for ${metrics.length} wallets`)
  console.log()

  // Simulate $1 per position with actual win rate and avg win/loss
  interface SimResult {
    wallet: string
    note: string
    win_rate: number
    avg_win_pct: number
    avg_loss_pct: number
    win_loss_asymmetry: number
    positions: number
    resolved: number
    // Simulation results
    simulated_roi: number
    simulated_return_per_100: number
    kelly_fraction: number
    edge_ratio: number
    actual_realized_pnl: number
    pnl_confidence: string
  }

  const results: SimResult[] = []

  for (const m of metrics) {
    const walletInfo = TOP_WALLETS.find(w => w.wallet.toLowerCase() === m.wallet.toLowerCase())

    const win_rate = parseFloat(m.win_rate)
    const avg_win_pct = parseFloat(m.avg_win_pct) / 100  // Convert from percent
    const avg_loss_pct = Math.abs(parseFloat(m.avg_loss_pct)) / 100  // Convert from percent, make positive

    // Expected value per $1 bet:
    // EV = (win_rate * avg_win) - ((1 - win_rate) * avg_loss)
    const ev_per_dollar = (win_rate * avg_win_pct) - ((1 - win_rate) * avg_loss_pct)

    // Simulated ROI over positions
    const simulated_roi = ev_per_dollar * 100  // As percentage

    // Per 100 positions
    const simulated_return_per_100 = ev_per_dollar * 100  // $100 invested, return

    // Kelly Criterion: f* = (p * b - q) / b
    // where p = win probability, q = loss probability, b = win/loss ratio
    const b = avg_loss_pct > 0 ? avg_win_pct / avg_loss_pct : 0
    const kelly = b > 0 ? (win_rate * b - (1 - win_rate)) / b : 0

    results.push({
      wallet: m.wallet,
      note: walletInfo?.note || '',
      win_rate,
      avg_win_pct: parseFloat(m.avg_win_pct),
      avg_loss_pct: parseFloat(m.avg_loss_pct),
      win_loss_asymmetry: parseFloat(m.win_loss_asymmetry) || 0,
      positions: parseInt(m.positions_count),
      resolved: parseInt(m.resolved_positions),
      simulated_roi,
      simulated_return_per_100,
      kelly_fraction: Math.max(0, kelly),  // Don't go negative
      edge_ratio: parseFloat(m.edge_ratio),
      actual_realized_pnl: parseFloat(m.realized_pnl),
      pnl_confidence: m.pnl_confidence
    })
  }

  // Sort by simulated ROI
  results.sort((a, b) => b.simulated_roi - a.simulated_roi)

  // Print detailed results
  for (const r of results) {
    console.log(`╔═══════════════════════════════════════════════════════════════════╗`)
    console.log(`║ ${r.wallet.slice(0, 42)}`)
    console.log(`║ ${r.note}`)
    console.log(`╠═══════════════════════════════════════════════════════════════════╣`)
    console.log(`║ Win Rate:       ${(r.win_rate * 100).toFixed(1)}%`)
    console.log(`║ Avg Win:        +${r.avg_win_pct.toFixed(1)}%`)
    console.log(`║ Avg Loss:       ${r.avg_loss_pct.toFixed(1)}%`)
    console.log(`║ W/L Asymmetry:  ${r.win_loss_asymmetry.toFixed(2)}x`)
    console.log(`║ Positions:      ${r.positions} (${r.resolved} resolved)`)
    console.log(`╠═══════════════════════════════════════════════════════════════════╣`)
    console.log(`║ SIMULATION (per $1 bet):`)
    console.log(`║   Expected ROI:     ${r.simulated_roi >= 0 ? '+' : ''}${r.simulated_roi.toFixed(2)}%`)
    console.log(`║   Per 100 trades:   ${r.simulated_return_per_100 >= 0 ? '+' : ''}$${r.simulated_return_per_100.toFixed(2)}`)
    console.log(`║   Kelly Fraction:   ${(r.kelly_fraction * 100).toFixed(1)}% of bankroll`)
    console.log(`║   Edge Ratio:       ${r.edge_ratio.toFixed(2)}x breakeven`)
    console.log(`╠═══════════════════════════════════════════════════════════════════╣`)
    console.log(`║ ACTUAL TRACK RECORD:`)
    console.log(`║   Realized PnL:     $${r.actual_realized_pnl.toFixed(2)}`)
    console.log(`║   Confidence:       ${r.pnl_confidence}`)
    console.log(`╚═══════════════════════════════════════════════════════════════════╝`)
    console.log()
  }

  // Leaderboard
  console.log()
  console.log('╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════╗')
  console.log('║                                    COPY TRADING SIMULATION LEADERBOARD                                        ║')
  console.log('╠═══════════════════════════════════════════════════════════════════════════════════════════════════════════════╣')
  console.log('║ Rank │ Wallet              │ WinRate │ AvgWin │ AvgLoss │ W/L   │ Exp.ROI │ Kelly  │ Actual PnL │ Conf    ║')
  console.log('╠══════╪═════════════════════╪═════════╪════════╪═════════╪═══════╪═════════╪════════╪════════════╪═════════╣')

  for (let i = 0; i < results.length; i++) {
    const r = results[i]
    const row = [
      String(i + 1).padStart(4),
      r.wallet.slice(0, 18).padEnd(18),
      `${(r.win_rate * 100).toFixed(0)}%`.padStart(7),
      `+${r.avg_win_pct.toFixed(0)}%`.padStart(6),
      `${r.avg_loss_pct.toFixed(0)}%`.padStart(7),
      `${r.win_loss_asymmetry.toFixed(1)}x`.padStart(5),
      `${r.simulated_roi >= 0 ? '+' : ''}${r.simulated_roi.toFixed(1)}%`.padStart(7),
      `${(r.kelly_fraction * 100).toFixed(0)}%`.padStart(6),
      `$${r.actual_realized_pnl.toFixed(0)}`.padStart(10),
      r.pnl_confidence.padStart(7)
    ].join(' │ ')
    console.log(`║ ${row} ║`)
  }

  console.log('╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════╝')

  // Summary
  console.log()
  console.log('📊 INTERPRETATION:')
  console.log('   - Expected ROI = (WinRate × AvgWin) - ((1-WinRate) × |AvgLoss|)')
  console.log('   - Kelly = optimal fraction of bankroll per bet for max growth')
  console.log('   - Positive Kelly = edge exists, safe to copy')
  console.log('   - Kelly > 20% = STRONG edge')
  console.log()

  // Save results
  const fs = await import('fs')
  fs.writeFileSync(
    '/Users/scotty/Projects/Cascadian-app/scripts/experimental/results/simulation-results-v3.json',
    JSON.stringify(results, null, 2)
  )
  console.log('📁 Results saved to results/simulation-results-v3.json')

  return results
}

runSimulation()
  .then((results) => {
    const profitable = results.filter(r => r.simulated_roi > 0)
    console.log(`\n✅ Simulation complete! ${profitable.length}/${results.length} wallets have positive expected value.`)
    process.exit(0)
  })
  .catch((error) => {
    console.error('Simulation failed:', error)
    process.exit(1)
  })
